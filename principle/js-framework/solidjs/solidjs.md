# 入门

## 理念

### 1. 声明式数据

声明式数据是将数据行为的描述与其声明联系起来的实践。这允许我们通过将数据行为的所有方面打包在一个地方来轻松组合。

### 2. 消失的组件

在不考虑更新的情况下构建组件已经够难的了。Solid 的组件更新是彼此完全独立的。组件函数被调用一次，然后就不再存在。组件的存在是为了组织你的代码，而不是其他。

* 构建组件已经够难的了，比如说构建react组件
* solid中组件函数只会被调用一次，然后就不会存在了。还在使用组件最大的作用就是用来组织你的代码，而不是其他

### 3. 读、写 分离

精确的控制和可预测性有助于打造更好的系统。我们不需要真正的不变性来强制执行单向数据流，只需要能够有意识到哪些消费者可能会写，哪些可能不会。

* 数据可预测，但是没有强约束，需要开发者有相关意识

### 4. 简单胜于容易

细粒度响应性教会我们：明确且一致的约定即使需要更多努力也是值得的。且有必要提供最少的工具作为构建的基础。

* solid 认为他们为实现简单开发做的编译方面的努力是值得的，比如需要更加困难的算法
* 简单意味着开发人员需要做更少的工作（留给框架开发人员）；容易意味着开发人员需要做容易的事，并不一定意味着工作量会变少，只要开发人员做的事多，那么就意味着更容易出错，并不意味着能做好。

## signal

Signal 是最核心的响应式基本要素（primitive）。Signal 包含随时间变化的值。

* 可以在函数组件内创建，也可以在函数组件外创建

```tsx
const [count, setCount] = createSignal(0)

// 使用
<button onClick={() => setCount((count) => count + 1)}>
  count is {Date.now()} {count()}
</button>
```

### 值的函数表达

* 获取值使用函数表达的方式，更容易收集依赖，做编译时优化。

## effect

Signal 是可追踪的值，但它们只是等式的一半。另一半是观察者，也就是计算。最基本的计算称为 Effect，它产生副作用 —— 我们系统的输出。

> 但要了解 Solid 的工作原理，你应该想象 JSX 中的每个表达式都可能是一个单独包装的 Effect，它会在其依赖信号发生变化时重新执行。这就是 Solid 中所有渲染的工作方式。从 Solid 的角度来看，`所有渲染都只是响应系统的副作用`。

* solid 关于其副作用的描述

### 副作用

* 副作用函数的执行可能会影响函数的输出（也就是UI），意味着函数将不再是纯函数，每次输出不是固定的。



## 特点

* 没有虚拟DOM，不需要进行diff计算节省成本
* 借鉴了 React hooks` + `vue3 特点，写法与react相似，有响应式状态系统。
* 不需要像 useEffect 那样添加依赖，自动进行状态跟踪，实现精确渲染
* `hook`调用顺序没要求，以函数调用的方式解决`Proxy`目标必须是对象的问题

# 组件库

## 和 tailwind css 集合

推荐：https://daisyui.com/docs/install/?lang=zh_hans