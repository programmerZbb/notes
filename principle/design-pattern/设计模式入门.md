# js中的设计模式

## 1. 什么是设计模式

一个模式就是一个可重用的方案，可应用于在软件设计中的常见问题 。

好处：

代码的健壮性、代码的复用、代码的简洁（DRY don't repeat yourself）、快速开发。

是一种解决方案，不是确切的解决方案。



# JavaScript设计模式与开发实践

## 1. 面向对象

> “JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 



### 1.0 class

* class 就是数据和逻辑的封装



鸭子类型 + 函数一等公民

### 1.1 鸭子类型

* js 对象能够调用某属性，而不用考虑该属性是否原本被设计为被拥有

* 这一切都建立在鸭子类型的概念上（duck typing）

  > “如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

  > “鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注HAS-A, 而不是IS-A。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### 1.2 动态类型的语言是怎么面向对象的

> “在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，==我们不必借助超类型的帮助==（不需要定义一个类来描述），就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。”
>
> “例如，一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 也就是说，JavaScript的面向对象时反向操作的，是先有描述，然后去实现这个描述，只需要实现描述的方法（多余方法可以自定义）

### 1.3 静态类型语言中的面向接口编程实现

> “在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过==抽象类或者接口等将对象进行向上转型==。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在类型检查系统的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 需要向上抽象、转型

* ==“面向接口编程”是设计模式中最重要的思想”==

### 1.4 多态

> “多态”一词源于希腊文polymorphism，拆开来看是poly（复数）+ morph（形态）+ ism（系统），从字面上我们可以理解为复数形态”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 实际含义：

  “同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。”

  接口约束对象（公共部分），多态让对象表达自己。
  
  对象层面的if else

* ==多态的目的就是把程序中不变的部分隔离出来，然后把可变的部分封装起来。==



#### 多态的表达

* 根据开闭原则，需要对扩展开放，不允许修改（是不安全的，并且可能操作方法变得臃肿）。

  相对于修改来说，仅仅增加代码就能完成同样的功能，这样显得优雅和安全多了

* ==“多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来==，也就是将“不变的事物”与 “可能改变的事物”分离开来。”（尽可能抽离common的部分）

### js中的多态

* 一个js对象既可以表示a，又可以表示b，js中的多态是与生俱来的。在编译时没有类型检查的过程，对象的类型和函数的参数都不会检查类型。

* 由此可见一个对象能够发出叫声，只取决于它是否存在makeSound方法，不去取决于是哪种类型的对象。==这里的思维和java中的相反，Java会先去找对象而js会先去找方法，这一切都归因于类型系统==

* 多态是面向对象最重要的特性吗？

  > “换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。”
  >
  > 把if else 转换成对象的多态性
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

#### js 中多态的表现

> “在JavaScript这种将函数作为一等对象的语言中，函数本身也是对象，函数用来封装行为并且能够被四处传递。当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在JavaScript中可以用高阶函数来代替实现的原因”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 导演那个例子非常生动形象！

### 多态的问题

* 如果多态的使用都需要同一个方法，比如说show。当时有的对象没有show方法，而是其他的方法，则可采用适配器来进行适配，多态收敛入口，统一调用show方法

## 2. 封装

* “封装的目的是将信息隐藏”——class 就是数据和逻辑的封装

### 面向对象封装

* 封装在一起，然后控制成员的访问权限

>  “在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了private、public、protected等关键字来提供不同的访问权限。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### 封装的实现

> “从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### 封装类型

> “封装类型是静态类型语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的4。把对象的真正类型隐藏在抽象类或者接口之后，==相比对象的类型，客户更关心对象的行为==”。这就是为什么封装抽象类和接口
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 在一些静态语言的设计模式中，会想方设法的隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等。

  > “对于JavaScript的设计模式实现来说，不区分类型是一种失色，也可以说是一种解脱。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### 封装变化

“从设计模式的角度出发，封装在更重要的层面体现为封装变化。”

> 考虑你的设计中哪些地方可能变化，这种方式与关注会导致重新设计的原因相反。“它不是考虑什么时候会迫使你的设计改变，而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念，这是许多设计模式的主题。”
>
> 很多设计模式的出发点就是封装变化

> “这段文字即是《设计模式》提到的“找到变化并封装之”。《设计模式》一书中共归纳总结了23种设计模式。==从意图上区分，这23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。==”

> ==这段非常重要：==
>
> “拿创建型模式来说，要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的，创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。”
>
> 创建型模式->封装创建对象的变化
>
> 结构型模式->对象之间的组合关系
>
> 行为型模式->对象的行为变化

“通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。==这可以最大程度地保证程序的稳定性和可扩展性。==

* 设计模式副标题 可复用：想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了

==封装变化才是封装的出发点，之前的封装类型、多态等只是具体的实现方案，以便于实现最大的可复用==



## 原型模式和基于原型继承的JavaScript对象系统

“而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的”。通过克隆人同样可以创建另一个人，而不是传统那样用铸模来创建

“原型模式不单是一种设计模式，也被称为一种编程泛型。”

### 使用克隆的原型模式

“从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。”

* 原型模式的实现关键，是语言本身是否提供了clone方法，es5提供了 Object.create 方法，能够用来clone对象。（实际上是把create方法中的参数加到了原型链上）
* 克隆只是创建对象的手段。原型模式的真正目的并非在于需要得到一个一模一样的对象，而是==提供一种便捷的方式去创建某个类型的对象==，克隆只是创建这个对象的过程和手段。



JavaScript所有的对象都是从某个对象上克隆而来的，没有类的概念。js就是使用原型模式来搭建整个面向对象系统的。

* ==通过克隆的方式创建对象，一定有一个万物起源，比如说js中的Object。所有的对象都是由它克隆而来的——根对象，也就是原型==

## 原型编程范型的一些规则

* 基于原型链的委托机制就是原型继承的本质

1. 特性1

   “现在我们明白了原型编程中的一个重要特性，即当对象无法响应某个请求时，会把该请求委托给它自己的原型。”



==基本规则==

1. 所有的数据都是对象。
2. ==要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。==——这个是精髓，包括 `let test = true`也是这种方式，通过找到Boolean对象并克隆了它。
3. 对象会记住它的原型。
4. 如果对象无法响应某个请求，它会把这个请求==委托==给它自己的原型。



## js中的原型链继承

对应上边基本规则

1. ==除undefined外，都是对象==

   * ==js 中根对象就是 `Object.prototype`==，它的 `__proto__` 就是null

   > “事实上，JavaScript中的根对象是Object.prototype对象。Object.prototype对象是一个空的对象。我们在JavaScript遇到的每个对象，实际上都是从Object.prototype对象克隆而来的，Object.prototype对象就是它们的原型。”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

   * `Object.getPrototypeOf` 方法能够获取该对象的第一个原型，todo记录到Object方法中！！！

   ```js
   Object.getPrototypeOf([]) === Array.prototype
   // true
   ```

   * ==一定注意：所有的原型都说的是原型对象，不是构造函数。都是构造函数的prototype==

2. '要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它'

   js内部引擎会负责实现克隆的细节，我们只需要显示的调用var obj1 = {}，引擎内部就会从 Object.prototype 上面克隆一个对象出来，我们最终就会得到这个对象。

3. 

   > “目前我们一直在讨论“对象的原型”，就JavaScript的真正实现来说，其实并不能说对象有原型，而只能说==对象的构造器有原型==。”

   ==注意：不能通过修改\_\_proto\_\_ 直接修改继承，必须通过修改构造函数原型的方式来实现==

### Object.create问题

* 这个方法创建对象效率不高，通常比通过构造函数创建对象慢

* > “此外还有一些值得注意的地方，比如通过设置构造器的prototype来实现原型继承的时候，除了根对象Object.prototype本身之外，任何对象都会有一个原型。==而通过Object.create( null )可以创建出没有原型的对象。==
  >



## 总结

* 原型模式既是一种设计模式也是一种编程泛型



## 面向对象编程法则总结

### 应用——控制反转（IOC）和 依赖注入（DI）

阅读：

https://zhuanlan.zhihu.com/p/33492169

https://segmentfault.com/a/1190000008626680

* 如果类 A 依赖 B，需要进行依赖解耦，交出控制权。——空

### 控制反转

Ioc 不是一种技术，只是一种思想，一个重要的面向对象编程法则，它能指导我们如何设计松耦合、更优良的系统。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器注入组合对象，所以对象之间是松散耦合，这样也便于测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。　　

其实 IoC 对编程带来的最大改变不是从代码上，而是思想上，发生了"主从换位"的变化。应用程序本来是老大，要获取什么资源都是主动出击，但在 IoC思想中，应用程序就变成被动了，被动的等待 IoC 容器来创建并注入它所需的资源了。　

### 依赖注入

DI - Dependency Injection，即"依赖注入"：组件之间的依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。



# 总结一下 this apply call

## this

> “跟别的语言大相径庭的是，JavaScript的this总是指向一个对象，而具体指向哪个对象是==在运行时基于函数的执行环境动态绑定的==(回顾一下js的执行context)，而非函数被声明时的环境。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 



四种使用：

“作为对象的方法调用。

作为普通函数调用。

构造器调用。

Function.prototype.call或Function.prototype.apply调用。”



## 不得不再说一下的call和apply

* 动态绑定this的方法
* apply 第二个参数是一个数组或者类数组
* 可以方便借用其他对象的方法，比如使用Math.max

### bind 呢

* bind静态绑定，绑定之后就不能再改变了，因为用了赋值的方式，闭包问题，局部变量没有释放，永远改变不了this





# 闭包和高阶函数

* 都是js函数式编程特性

## closure

* todo再去看看作用域



### 闭包和内存管理

“全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。”

* 闭包本身的内存释放问题，如果你确实需要使用这个变量，保存的闭包中和保存到全局变量，消耗内存没有区别的。真有可能内存泄露，可能是引用计数中的循环引用问题——ie的实现
* 释放内存——将变量设置为null意味着切断变量与它此前引用的值之间的连接



## ==合理利用缓存==

* 不管在项目开发中还是在正常计算中，需要能够提供cache，让响应更快。



## 闭包和面向对象设计

> “==过程(方法)与数据的结合是形容面向对象中的“对象”时经常使用的表达==。对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 通常用面向对象思想能实现的功能，用闭包也能实现

### 闭包面向对象转换

* 把局部变量当成对象的成员。TODO



## 高阶函数

高阶函数是指至少满足下列条件之一的函数

* 函数可以作为参数被传递；

* 函数可以作为返回值输出

### 函数作为参数

### 函数作为返回值

### 高阶函数实现AOP

* AOP（面向切面编程）Aspect 方面、切片 Oriented Programming

  > “AOP（面向切面编程）的主要作用是==把一些跟核心业务逻辑模块无关的功能抽离出来==，这些跟业务逻辑无关的功能==通常包括日志统计、安全控制、异常处理等==。把这些功能抽离出来之后，再通过“==动态织入==”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 在js中实现 AOP 似乎是一个非常简单的事，js中的函数是一个随便转播的。例如react的hooks就可以方便的解决横切关注点的问题。

  [为啥使用 useEffect](https://zh-hans.reactjs.org/docs/hooks-intro.html#complex-components-become-hard-to-understand)，之前使用class组件，生命周期使得复杂组件变得难以理解，如果不同的事件写在不通的生命周期中，很容易造成bug，并且导致逻辑不一致。

在js中动态织入方式有很多，本次主要是用过扩展 Function.prototype 来实现

### currying——部分求值

* currying又称为部分求值，函数科里化

>“currying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。”



### uncurrying

> “在JavaScript中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 就是把一个原型上函数改造成一个独立的函数，不去关心他挂载到什么对象上，只关注于它的作用

```js
// 把原生的方法进行改造，去掉this泛化的过程

// eg1: array push方法改造
Function.prototype.unCurrying = function () {
    let _self = this

    return function() {
        let obj = Array.prototype.shift.call(arguments)
        _self.apply(obj, arguments)
    }
}

let push = Array.prototype.push.unCurrying()

let arr = [1,2,3]
push(arr, 1, 2)
console.log(arr)

```



### 函数节流

* DOM 相关的操作是非常消耗性能的？todo为什么，和自己理解的一样吗？树查找，然后修改，然后渲染？

### 分时函数

* 问题：用户主动调用，但是数据量很大，前端自己分页去创建。类似于实际项目中的分页

  例子：创建qq好友列表，如果有1000个好友，不可能一下渲染完成，需要改成每200ms创建8个阶段。需要使用timeChunk方法

  > “timeChunk函数接受3个参数，第1个参数是创建节点时需要用到的数据，第2个参数是封装了创建节点逻辑的函数，第3个参数表示每一批创建的节点数量”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### 惰性加载函数

* 只有使用的时候才能确定，不使用的时候，不会确定

### 组合函数

* 函数组合就是怎么样让两个函数表达，比如说函数作为参数或者其他的方式。



## 总结

* JavaScript中很多设计模式都是通过闭包+高阶函数实现的，这并不奇怪，相对于设计模式的实现过程，我们更关注模式可以帮助我们完成什么
* Todo 这几种函数式编程的例子



# 设计模式

## 单例模式

* > “单例模式的定义是：==保证一个类仅有一个实例，并提供一个访问它的全局访问点。==”
  >
  > 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等。
  >
  > “在JavaScript开发中，单例模式的用途同样非常广泛。试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. \

  * 系统中唯一被使用
  * 一个类只有一个实例

* 登录框

* 购物车

  只能有一个实例，不能有多个

### 透明的单例模式

* 像一个普通的构造函数一样，直接使用 new 生产出一个实例

### 用代理实现单例

* 单一职责，实现功能单一

### js 中的单例模式

> “但JavaScript其实是一门无类（class-free）语言，也正因为如此，生搬单例模式的概念并无意义。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 如果直接使用全局变量实现一个单例，就会造成全局变量污染的情况，是一种糟糕的情况

#### 降低全局变量带来的命名污染

1. 使用命名空间

   > “适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

   * 说白了就是对全局暴露一个变量，其他的都是它的属性

2. 使用闭包封装私有变量

   > “我们用下划线来约定私有变量__name和__age，它们被封装在闭包产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命令污染。”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

#### 用ts实现单例

```typescript
class SingleCase {
    protected static _instance: SingleCase | null = null

    constructor () {
        if (SingleCase._instance != null) {
            return SingleCase._instance
        }
        SingleCase._instance = this
    }
}
```

* constructor 如果有返回值且是引用类型，则采用该引用类型



### 惰性单例

* 只有需要的时候才会创建

### 通用的惰性单例

todo

## 迭代器模式

* 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素

### 内部迭代器

* 迭代过程已经在内部写好，会一股脑的迭代完成

### 外部迭代器

* 迭代过程由外界控制



### 迭代器和if else 的使用场景

* 如果每个分支条件即使返回值，可以使用迭代器



## 策略模式

* 定义一些列的算法，把它们一个个封装起来，并且使它们可以互相替换

将变化的部分和不变的部分隔开是每个设计模式的主题，策略模式的目的就是将算法的使用与算法的实现分离开来。

### 实现

一个基于策略模式的程序至少由两个部分组成

* 一组策略类，策略类封装了具体的算法，并负责具体的计算过程。

* 环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。

  要做到这点，说明Context中要维持对某个策略对象的引用

整体来说就是具体的算法策略，由使用时外界传入。（使用的时候设置策略）



### js中的策略模式

* 唯一区别就是不需要封装策略类，直接由context函数调用一个策略map

### 多态在策略模式中的提现

> “通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算奖金有关的逻辑不再放在Context中，而是分布在各个策略对象中。Context并没有计算奖金的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 



## 发布订阅模式

* 发布订阅又叫观察者模式，它定义了对象间的一种==一对多==的依赖关系，当一个对象的状态发生改变的时候，所有依赖它的对象都将得到通知。
* 在JavaScript开发中，我们一般用事件模型来代替传统的发布订阅模式

> 发布-订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者

### 作用

1. 发布订阅可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。不需要关注什么时候成功、失败的状态

2. 取代对象之间硬编码（hardcode）的通知机制，一个对象不用显式调用另一个对象的某个接口。让两个对象松耦合地联系在一起，虽然不清楚彼此的细节，但不影响他们之间相互通信。

   只要约定的事件名称没有改变，就可以自由地改变他们。

### 常见

1. DOM事件 on 订阅
2. Todo js 自定义事件



### 通用的发布订阅模式

* 提供注册能力
* 提供删除能力

### 全局的发布订阅

* 中介

### 模块间通信

* 模块间通信使用一个中间的观察者，可以非常方便的进行模块间的通信。
* 存在的问题：如果使用了太多的全局发布订阅模式来通信，那么模块与模块间的联系就会被隐藏到背后，我们最终就会搞不清楚消息来自那个模块，或者消息流向那个模块，==这又会给全局的维护者带来一些麻烦==，也许某个模块的作用就是暴露一些接口给其他模块

堆栈？（浏览器渲染原理）



### js发布订阅

* 推模型
* 拉模型



### 总结

优点：

* 时间上的解耦，完美处理异步事件
* 对象之间的解耦，完全感知不到对方的存在

>  “发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。 从架构上来看，无论是MVC还是MVVM，都少不了发布—订阅模式的参与，而且JavaScript本身也是一门基于事件驱动的语言。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

缺点：

* 消息的交叉，追踪难度
* 订阅者消耗时间、内存，有的消息可能始终都未发生，内存还是会消耗。如果有多个观察者，消息来源和走向不明，找bug比较困难

### 优点和缺点

优点：

- 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。
- 符合依赖倒置原则。
- 目标与观察者之间建立了一套触发机制。
- 支持广播通信

不足：

- 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。（如果依赖另一个依赖被观察者对象的对象）
- 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。（如果一个模块并不想知道其他模块是否存在，可能影响到这个模块的执行）

https://juejin.cn/post/6910943445569765384

https://developer.aliyun.com/article/953137

## 外观模式

* 外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口值得这一子系统更加容易使用。

  更倾向于提供原来没有的，为了易于应用的接口。



## 适配器模式

适配器模式的作用就是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。

适配器的别名是包装器（wrapper），这是一个相对简单的模式。

* 如果一个接口实现过于复杂，没必要去修改接口实现，而是包装一个适配器达到使用要求。
* 场景可太多了：比如说内核的错误转换，使用包装等。



### 适配器模式的应用

* 如果现有的接口已经能够正常工作，那我们永远不会用上适配器模式，适配器模式是一种‘亡羊补牢’的模式，没有人会在程序的设计之初就使用它。

  > “==因为没有人可以完全预料到未来的事情，==也许现在好好工作的接口，未来的某天却不再适用于新系统，那么我们可以用适配器模式把旧接口包装成一个新的接口，使它继续保持生命力。比如在JSON格式流行之前，很多cgi返回的都是XML格式的数据，如果今天仍然想继续使用这些接口，显然我们可以创造一个XML-JSON的适配器。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

  * 也有可能是人家就没有这种场景，你为了使用，必须适配

  todo: xml - json 是怎么做的，jsx -> reactElement



### 和其他设计模式的区别

与装饰者模式、代理模式和外观模式区别

* 适配器模式主要是用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是如何实现的，也不开了他们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用

* 装饰着模式和代理模式也不会改变原有的对象的接口，但装饰着模式的作用是为了给对象增加功能。

  > “装饰者模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但是外观模式最显著的特点就是定义了一个新的接口。

  > 外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口值得这一子系统更加容易使用。

  目的性不同：适配器是原来别人都这么用，突然有一个功能不是这么用，然后去适配；外观模式是一开始别人用的不舒服、设计不合理，提供一个更易于使用的接口。

todo: 自己理解呢

# 工厂模式

* 将new 操作单独封装
* 遇到 new 时，就要考虑是否要使用工厂模式

举例：

* 去买汉堡，不需要亲自动手，商店将封装好的汉堡给你



# 设计原则和编程技巧（待补充全）

* 设计模式本身就是迎合一个或多个设计原则，他们本身已经融入了设计模式之中，给面向对象编程指明了方向。

设计原则

* 单一职责
* 里式替换
* 依赖倒置
* 接口隔离
* 合成复用
* 最少知识



## 1. 单一职责

SRP single responsibility principle

* 就一个类而言，应该仅有一个引起它变化的原因。

> “单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，==需要改写这个方法的可能性就越大。==”
>
> 1/4 1/4 15/16的概率
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 修改一个方法影响范围太大，同样适用于研发流程

  一个职责的变动可能会影响其他职责的实现，造成意想不到的破坏，这种耦合性得到的是低内聚和脆弱的设计。

* 因此SRP原则体现为：一个对象（方法）只做一件事

### 设计模式中的SRP原则

* 一个对象（方法）只做一件事——宗旨

### 何时应该分离职责

* SRP原则是所有原则中最简单也是最难正确运用的原则之一。需要明确的是不是所有的职责都应该一一分离的

  > “一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在ajax请求的时候，创建xhr对象和发送xhr请求几乎总是在一起的，那么创建xhr对象的职责和发送xhr请求的职责就没有必要分开。
  >
  > 另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* Todo 高内聚？啥意思

### 违反SRP原则

“一方面，我们受设计原则的指导，另一方面，我们未必要在任何时候都一成不变地遵守原则”

“在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。”

* 比如说一个方法技能获取值、又能设置值

### SRP原则优缺点

有点：复用、降低复杂度、单元测试、功能独立维护简单

“SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。”

摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

缺点：拆分到更小的颗粒度后，对象之间的互相联系难度增加。

“但SRP原则也有一些缺点，最明显的是会增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互联系的难度。”

## 2. 最少知识原则

least knowledge principle

“最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。” 尽可能少地影响更多的实体

> “某军队中的将军需要挖掘一些散兵坑。下面是完成任务的一种方式：将军可以通知上校让他叫来少校，然后让少校找来上尉，并让上尉通知一个军士，最后军士唤来一个士兵，然后命令士兵挖掘一些散兵坑。”
>
> “让代码通过这么长的消息链才能完成一个任务，这就像让将军通过那么多繁琐的步骤才能命令别人挖掘散兵坑一样荒谬！而且，这条链中任何一个对象的改动都会影响整条链的结果。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 单一职责描述的是一个对象内部层面的降耦原则，可以提高对象的复用性，降低修改的概率。

  最少知识原则描述的是路径（依赖）层面的降耦原则，如果一个变化，在依赖路径上其他的有可能也需要修改

  > “但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。在程序中，对象的“朋友”太多并不是一件好事，“城门失火，殃及池鱼”和“一人犯法，株连九族”的故事时有发生。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 引入第三者，也就是信息中心来承担通信作用，不要和太多模块直接通信

> “最少知识原则要求我们在设计程序时，==应当尽量减少对象之间的交互==。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。
>
> ”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### 设计模式中的最少知识原则

“在世界杯期间购买足球彩票，如果没有博彩公司作为中介，上千万的人一起计算赔率和输赢绝对是不可能的事情。博彩公司作为中介，每个人都只和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就赔给博彩公司”

“中介者模式很好地体现了最少知识原则。通过增加一个中介者对象，让所有的相关对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可。

* 外观模式的提现

  约束一个统一的外观接口，减少和外界的直接联系。有一个懂业务好沟通的前台小姐姐



#### 补一个外观模式

* 为一组子系统提供一个简单便利的访问入口。

* 隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节。

##### 外观模式和封装的区别

* 封装是封装一个类，外观模式封装的是一组子系统，是一个更高层级的接口。

  > “子系统在C++或者Java中指的是一组类的集合，这些类相互协作可以组成系统中一个相对独立的部分。在JavaScript中我们通常不会过多地考虑“类”，如果将外观模式映射到JavaScript中，这个子系统至少应该指的是一组函数的集合。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 最简单的外观模式实现

  ```typescript
  var A = function(){
      a1();
      a2();
  }
  
  var B = function(){
      b1();
      b2();
  }
  
  var facade = function(){
      A();
      B();
  }
  
  facade(); 
  ```

* 注意：外观模式除了访问外观接口，还可以访问内部的子系统。这也是区分外观模式和其他模式（比如封装，代理是一对一，外观一对多）的一个特点

* ==外观和观察者模式的区别==：外观是对调用的封装，不涉及相互通信。观察者是每个订阅的系统需要相互通信。外观更像更高层（系统层面）的封装，但是内部的系统不是外观接口的私有属性，外界可以随意访问。

* 总结

  外观模式是符合最少知识原则的，隔离开使用者和子系统的直接联系，客户不需要了解子系统的具体能力、接口。



#### 封装在最少知识原则中的提现

==封装在很大程度上表达的是数据的隐藏==。

==js中对变量作用域的规定是：==（也就是怎么样定义的变量才有用）

* 变量在全局声明，或者==在代码的任何位置==隐式声明（不用var，直接赋值），则该变量在全局可见；
* 变量在函数内显示声明（使用var），则在函数内可见。（不显式声明，则为全局变量）

> “把变量的可见性限制在一个尽可能小的范围内，这个变量对其他不相关模块的影响就越小，变量被改写和发生冲突的机会也越小。这也是广义的最少知识原则的一种体现。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 



## 3. 开放-封闭原则

* 在面向对象的程序设计中，==开放-封闭原则（ocp）是最重要的一条原则==。很多时候，一个程序具有良好的设计，往往说明它是符合开放-封闭原则的。
* 定义：软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。

### 为什么需要

* 改动代码是一种危险的行为，否则可能遇到bug越改越多的情况，刚刚改好了一个bug不知不觉中又引入了另一个bug。

### 怎么解决——维护时注意

* 我们通过增加代码，而不是修改代码的方式。

  比如：通过装饰器模式动态装饰一下，完全不用关心原来代码是好是坏，只要是一个稳定的方法，就没必要修改原来代码，做到井水不犯河水。

> “现在可以引出开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### 开放和封闭

“现在可以引出开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。”

摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### ==用对象的多态性消除条件分支==

> “==过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因。==每当需要增加一个新的if语句时，都要被迫改动原函数。把if换成switch-case是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的if或者swtich-case语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* 利用对象的多态性来让程序遵守开闭原则，是一个常用的技巧

例子：动物的叫声，完全不需要care动物怎么叫的是谁叫的，只要让每个动物都有叫这个接口。



### ==找到变化的地方==——开发时注意

* 开放封闭原则并没有提供一个模板叫我们实现它，但是我们还是能找到一些让程序尽量遵守的规律

  > “开放-封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导我们怎样亦步亦趋地实现它。但我们还是能找到一些让程序尽量遵守开放-封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 
  
  * 变化的地方就是可扩展的



* 因此，我们需要找到变化的部分，封装起来。==通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。==在系统演变的过程中，我们只需要修替换容易变化的部分，如果这些部分是封装好的替换起来也比较容易。而变化部分之外的就是稳定的部分，在系统的演变过程中，稳定的部分是不需要改变的。

  通过封装变化的部分就能够有效的让程序尽量符合开闭原则。

* 实现：

  比如说动物叫声的例子中，就是封装一个叫声的方法，然后if else 的实现由传入的对象决定。

### 其他方式

* 除了利用对象的多态之外，还有其他的方式帮助我们编写遵守开闭原则的代码

#### 1. 放置挂钩（hook）

> “==我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。==这样一来，原本的代码执行路径上就出现了一个分叉路口，==程序未来的执行方向被预埋下多种可能性。==”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

Todo: 需要查看第十一章的模板模式。

#### 2. 使用回调函数

* 在js中函数可以作为参数传递，这就是高阶函数的意义之一。

* 回调函数是一种特殊的挂钩，我们把一部分易于变化的逻辑封闭在回调函数中，然后把回调函数传入一个稳定的不变的函数中。当回调函数被执行时，程序就会因不同的回调产生不同的结果。

  eg: 

  * 也就常见的回调函数处理方式
  * 数组的map方法，映射的步骤是不变的，映射的规则是可变的



### 设计模式中的开闭原则——评价其他设计模式

* 几乎所有的设计模式都是遵守开闭原则的，我们见到好的设计模式都经得起开闭原则的考验。（个人理解：很多设计原则都是给开闭原则服务的，比如说单一原则）

  下面这段理解和我思考如出一辙

  > “不管是具体的各种设计模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等，都是为了让程序遵守开放-封闭原则而出现的”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

  ==可以这样说，开闭原则是编写一个好程序的目标，其他的设计原则都是达到这个目标的过程==

  

### 涉及到的设计模式

1. 装饰者模式

2. 发布订阅模式

   “发布-订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。”

   摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

3. 模板方法模式

   模板方法模式是一种典型的==通过封装变化来提高系统扩展性的设计模式==

   todo 了解

   > “在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放-封闭原则的”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

4. 策略模式

   “策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而==策略模式则偏重于组合和委托。==”

   摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

   Todo 了解

   > “策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

5. 代理模式

   todo 第6章

   * 很明显的通过封装增加的代理代码，遵守开闭原则。

6. 职责链模式

   todo 第14章

   > “在第14章的学习中，我们遇到过一个例子，把一个巨大的订单函数分别拆成了500元订单、200元订单以及普通订单的3个函数。这3个函数通过职责链连接在一起，客户的请求会在这条链条里面依次传递：”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

   * 更像在实现流程层面功能拆分，看起来需要符合最少知识原则



### 开闭原则的相对性——无法做到完全封闭怎么办

* 让程序保持完全的封闭是不容易做到的，有时候必须修改源码（比如antd样式覆盖啥的）

  > “实际上，让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间和精力。而且让程序符合开放-封闭原则的代价是引入更多的抽象层次，==更多的抽象有可能会增大代码的复杂度。==”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* ==强行符合开闭原则的代价就是需要引入更多的抽象层次。==



* 既然有时候做不到绝对的封闭，程序员应该怎么做？更适合于软件架构层面
  1. 挑出最容易发生变化的地方，然后构造抽象来封闭这些变化。比如说插件系统，中间件等
  2. 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单。

### 接受第一次愚弄

> “愚弄我一次，应该羞愧的是你。再次愚弄我，应该羞愧的是我。这也是一种有效的对待软件设计的态度。为了防止软件背着不必要的复杂性，我们会允许自己被愚弄一次”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 



### 开闭原则总结

* 重要的是找到变化的部分，找到变化的部分才能控制变量，最大程度的保护程序不被修改或者轻易被修改。



## 接口和面向接口编程

* 封闭然后提供接口通信，本来就是符合开闭原则的。

接口定义：

1. 库和模块对外提供的某某API接口

   > “我们经常说一个库或者模块对外提供了某某API接口。通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节。这也是我们最熟悉的第一种接口含义。”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

2. 语言层面的inferface

   > “第二种接口是一些语言提供的关键字，比如Java的interface。==interface关键字可以产生一个完全抽象的类。这个完全抽象的类用来表示一种契约，专门负责建立类与类之间的联系。==”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

3. 面向对象中的接口: 接口是对象能响应的请求的集合

   > “第三种接口即是我们谈论的“面向接口编程”中的接口，接口的含义在这里体现得更为抽象。用《设计模式》中的话说就是：接口是对象能响应的请求的集合”
   >
   > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

==向上转型是让对象表现出多态性的一条途径：目前有以下两种方案 抽象类和interface==

### java中的抽象类

* 静态类型语言通常设计为可以向上转型，可以使用超类去承接

* 向上转型一般都要定义interface或者抽象类，但是不可以是具体类

  > “也可以把Animal定义为一个具体类而不是抽象类，但一般不这么做。Scott Meyers曾指出，只要有可能，不要从具体类继承。具体类会引入具体的实现”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

  ==一定要用超类去承接，实现多态的效果==



抽象类在此有以下两个作用：

* 向上转型：让对象表现出多态性的必经之路——父类约束
* 建立一些契约：所有继承抽象类的具体类都需要复写抽象类中的abstract方法——接口约束

这两种方案本来就是面向接口编程的约束，脱离对象的具体类型，而是必须实现某些接口。

> “总而言之，不关注对象的具体类型，而仅仅针对超类型中的“契约方法”来编写程序，可以产生可靠性高的程序，也可以极大地减少子系统实现之间的相互依赖关系，这就是我们本章要讨论的主题：面向接口编程，而不是面向实现编程”
>
> “从过程上来看，“面向接口编程”其实是“面向超类型编程”。==当对象的具体类型被隐藏在超类型身后时，这些对象就可以相互替换使用==，我们的关注点才能从对象的类型上转移到对象的行为上。“面向接口编程”也可以看成面向抽象编程，即针对超类型中的abstract方法编程，接口在这里被当成abstract方法中约定的契约行为。这些契约行为暴露了一个类或者对象能够做什么，但是不关心具体如何去做。”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

### interface

* 除了用抽象类来完成面向接口编程之外，使用interface也可以达到同样的效果。
* inferface和抽象类的区别：相对于单继承的抽象类，一个类可以实现多个interface。抽象类中除了abstract方法外，还可以有子类公用的具体方法实现。inferface使抽象的概念更进一步，它产生一个完全抽象的类，不提供任何具体实现和方法体，但允许该interface的创建者确定方法名、参数列表和返回类型，这相当于提供一些行为上的约定，但是不关心该行为的具体实现。
* inferface同样可以用于向上转型，这也是让对象表现出多态性的一条途径，实现了同一个接口的两个类就可以被相互替换使用（就像一个方法的参数可以接受一个类或者一个接口，然后调用该参数的某个方法）

#### inferface相对于抽象类的优点

* 抽象类向上转型，引入了一个限制，抽象类是单继承的，也就是我们不可能让子类再继承另一个类；但如果使用了interface，仅仅针对某个行为进行实现，同时一个类也可以实现多个inferface



### js是否需要抽象类和interface

抽象类和interface主要是为了：子类表现多态性、约定类与类的行为，一个是表达不同、一个是约束相同（以继承和参数两方面看待）

* 通过向上转型来隐藏对象的真正类型，以表现对象的多态性。
* 约定类与类之间的一些契约行为

#### js中的超类

* 看一看待成所有的类型都向上转型成了Object类型

  ```js
  Array ary = new Array();
  Date date = new Date();
  // 看待成
  Object ary = new Array();
  Object date = new Date();
  ```

#### js中的面向接口编程

* 在js中很少关注真正的类型，在动态类型语言中，对象的多态性是与生俱来的，在一些静态语言中，对象和对象的解耦是非常重要的，甚至有一些设计模式主要目的就是隐藏对象的真正类型。

* ==因为不需要向上转型，接口在js中最大的作用就是退化到检查代码的规范性。比如一个对象输入之后需要检测参数的合法性==

  * 这也是js程序需要频繁检测输入的原因，如果不检测，可能出现bug

* js作为一个解释型动态类型语言，交给编译器是不靠谱的。参考JavaScript文档，解释性与编译型语言

  ![编译型语言和解释型语言的执行流程](http://c.biancheng.net/uploads/allimg/191231/1-1912311J415L7.gif)



### 用鸭子类型进行接口检测

鸭子类型是动态类型语言面向对象设计中的一个重要概念。

* 直接描述接口，而不是描述对象的实现。比较扁平不用向上转型

  > “比如，一个对象如果有push和pop方法，并且提供了正确的实现，它就能被当作栈来使用；一个对象如果有length属性，也可以依照下标来存取属性，这个对象就可以被当作数组来使用。如果两个对象拥有相同的方法，则有很大的可能性它们可以被相互替换使用。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

* js 程序中，总是进行接口检查是不明智的，也是没必要的，增加了一些与业务无关的代码



# 代码重构

* 模式和重构之间有一种与生俱来的关系。从某种角度来看，设计模式的目的就是为了许多重构行为提供目标。

* 在实际项目开发中，除了使用设计模式进行重构之外，还有一些常见而容易忽略的细节，这些细节也是帮助我们达到重构目标的重要手段。

  > “本章将挑选一些进行介绍，其中有一部分思想来自Martin Fowler的名著《重构：改善既有代码的设计》，虽然该书是使用Java语言写成的，但这些重构的技巧，有很大一部分可以为JavaScript语言所借鉴。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

## 提炼函数

* 能独立出来的最好独立放入另一个独立函数中

  > “避免出现超大函数。
  >
  > 独立出来的函数有助于代码复用。
  >
  > 独立出来的函数更容易被覆写。
  >
  > 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。
  >
  > ”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

  这也是ts的有点，相当于注释+提示

## 合并重复的条件片段

* 每个条件都出现的语句，直接写到条件结束时执行

## 把条件分支语句提炼成函数

* 一个判断条件，如果单独作为判断条件使用，可能需要判断多个条件，别人很难直接获取其意图，可以封装成一个独立的函数，既能达到目的，也能起到注释的作用

eg:

```typescript
// 原程序
function getPrice(price) {
  let date = new Date()
  if (date.getMethod()>6 && date.getMethod()<10) {
    return price * 0.8 // 夏季8折
  }
  return price
}

// 改造
function isSummer() { // 容易让人明白意图
  let date = new Date()
  return date.getMethod()>6 && date.getMethod()<10
}
function getPrice(price) {
  let date = new Date()
  if (isSummer()) {
    return price * 0.8 // 夏季8折
  }
  return price
}
```

## 合理利用循环



## 提前让函数退出代替嵌套条件分支

* 不要让维护者看那么多的if else，提前退出不要再看多余的代码，利于维护

  > “嵌套的条件分支语句绝对是代码维护者的噩梦，对于阅读代码的人来说，嵌套的if、else语句相比平铺的if、else，在阅读和理解上更加困难，有时候一个外层if分支的左括号和右括号之间相隔500米之远。用《重构》里的话说，嵌套的条件分支往往是由一些深信“每个函数只能有一个出口的”程序员写出的。但实际上，如果对函数的剩余部分不感兴趣，那就应该立即退出。引导阅读者去看一些没有用的else片段，只会妨碍他们对程序的理解。”
  >
  > 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 

## 用对象代替参数列表

* 如果参数列表过长，尽量使用对象的方式代替参数列表。使用函数时就没必要按索引位置对齐，只需要保证key value正确即可。



## 尽量减少参数数量——避免出现胖接口

* 避免出现不需要的参数传递，尽量精简接口



## 少用三目运算符

* todo 三目比if else 性能高？



## 合理使用链式调用

* 如果链式调用不是很稳定，其中一个节点出错，排查难度较大

> “链式调用带来的坏处就是在调试的时候非常不方便，如果我们知道一条链中有错误出现，必须得先把这条链拆开才能加上一些调试log或者增加断点，这样才能定位错误出现的地方。”
>
> “如果该链条的结构相对稳定，后期不易发生修改，那么使用链式调用无可厚非。但如果该链条很容易发生变化，导致调试和维护困难，那么还是建议使用普通调用的形式：”
>
> 摘录来自: 曾探. “JavaScript设计模式与开发实践。” Apple Books. 



## 分解大型类

* 面向对象设计鼓励将行为分布在合理数量的更小对象之中。如果一个对象的行为太过于庞大，可以单独抽象成一个类
  * 使用map的唯一性，做代码层面的if else



## 自己总结

### 合理注释

* 利于维护



### 引用归类

* 利于维护



# 后续todo

## 阅读

* https://www.cnblogs.com/winter-cn/archive/2012/03/10/2389575.html

  winter
