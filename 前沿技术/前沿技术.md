# 1. 微前端

* 老瓶装新酒，类似于前端开发中的模块拆分。
* 低耦合 高内聚，符合单一职责
* 目前大部分都是在路由层面进行拆分（最简单的方式）



## 特点

* 代码库拆分：简单、松耦合的代码库

* 增量升级：说白了还是代码隔离，互补干扰，版本不同

  > 这种增量升级的能力意味着我们能够*对产品功能进行低风险的局部替换*，包括升级依赖项、更替架构、UI 改版等。另一方面，也带来了技术选型上的灵活性，有助于新技术、新交互模式的实验性试错

* 独立部署、独立开发

  出事影响范围小，降低风险。

* 团队自治

* 独立运行时，与技术栈无关



## 实现方案

### 多 bundle 集成

微前端架构中一般会有个**容器应用（container application）**将各子应用集成起来，职责如下：

- 渲染公共的页面元素，比如 header、footer
- 解决横切关注点（cross-cutting concerns），如身份验证和导航
- 将各个微前端整合到一个页面上，并控制微前端的渲染区域和时机

集成方式分为 3 类：

- 服务端集成：如 SSR 拼装模板

- 构建时集成：如 Code Splitting

  常见的构建时集成方式是将子应用发布成独立的 npm 包，共同作为主应用的依赖项，构建生成一个供部署的 JS Bundle

  然而，**构建时集成最大的问题是会在发布阶段造成耦合**，任何一个子应用有变更，都要整个重新编译，意味着对于产品局部的小改动也要发布一个新版本，因此，**不推荐这种方式**

- 运行时集成：如通过 iframe、JS：比如前端路由、Web Components 等方式



值得注意的一点是 采用 web Components 的 Shadow DOM 的应用，可以搞沙箱隔离。

https://zhuanlan.zhihu.com/p/96464401



## 应用间通信

首先明确一点，跨应用之间的通信，不应该有大量数据。

* 路由通信，本来应用通信数据就少



## 个人想法

* 和 ssr 结合是不是能产出独特的效应。
* 拆分也要有度

### 问题

* 依赖路径边长，风险就变大 90% * 90% 风险
* 出了问题影响范围又变小，版本可以不一样
* 每个模块都需要降级方案，成本必然增大。



# 2. 服务端渲染

* ssr