# 2. 子网掩码

子网掩码(subnet mask)又叫[网络掩码](https://baike.baidu.com/item/网络掩码/7862514)、[地址掩码](https://baike.baidu.com/item/地址掩码/8623995)、子网络遮罩，它是一种用来指明一个[IP地址](https://baike.baidu.com/item/IP地址)的哪些位标识的是[主机](https://baike.baidu.com/item/主机/455151)所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成[网络地址](https://baike.baidu.com/item/网络地址/9765459)和[主机地址](https://baike.baidu.com/item/主机地址/9765500)两部分。

子网掩码是在[IPv4](https://baike.baidu.com/item/IPv4/422599)地址资源紧缺的背景下为了解决lP地址分配而产生的==虚拟lP技术==，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的==分配效率==，==有效解决了IP地址资源紧张的局面==。另一方面，在企业内网中为了==更好地管理网络==，网管人员也利用子网掩码的作用，人为地将一个较大的企业内部网络划分为更多个小规模的子网，再利用[三层交换机](https://baike.baidu.com/item/三层交换机/816331)的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。

## 怎么样计算

* 子网掩码是连续的 0 和 1。0用来掩盖主机 ip 地址，剩余的就是网络段。

```tex
255.255.255.0
# 末尾8个0，则能掩盖 256个主机。有连续的 1 24个，也可简称 192.168.1.0/24
255.255.252.0
# 先把252转换成二进制，末尾有 10 个0，则能掩盖 2^10 个主机。简称 192.168.1/22
```



# MAC地址

 https://www.zhihu.com/question/49335649/answer/1860224576

MAC是Media Access Control Address的缩写，是大部分IEEE 802网络设备使用的物理地址格式。这个地址用于==物理上直接可达的网络内的网络设备之间的通讯==，在ISO-OSI七层模型中位于第二层==数据链路层==。

MAC用于连接在==同一个局域网的网卡间==的直接通讯；通讯模式是用带着目标MAC地址的数据报文在网络中广播，只有地址正确的那个网卡才会接收这个报文，其它网卡不予理睬（设置为混杂模式除外）。

## 与 IP 不同

IP地址是网络层地址，它属于ISO-OSI七层协议的第三层网络层。

网络层协议是IP，底层协议是以太网。

IP地址的设计重点在于路由，也就是要考虑如何规划路径才能把报文投递给目标设备。主要是传递给指定的路由。

> 打个比方的话，IP地址类似于邮政编码，隐含了国家、地区、城市、街道等信息；携带IP地址信息的报文到了路由器之后，路由器要完成分拣工作、按照南来北往东投西递等不同方向给IP不同的报文分类、投递到正确的端口——比如，这一批邮件是发往X省的，都给997号班车；另一批邮件是发往Y省的，都给996号班车，等等。
>
> 等到了X省，那里的分拣中心（路由器）要进一步分拣，这一批到YP地区，走8235号班车；那一批到YY地区，走8233号班车，依此类推。
>
> 
>
> 最终，等邮件到了你所在小区（局域网），IP地址就无能为力了。它只管分拣（路由）这一层，不管数据链路层。

这时候怎么办呢？

转交给MAC地址，让它投递给正确的网卡。

因此，IP协议需要数据链路层协议承载才能工作，单靠它是完成不了消息投递工作的。

## 怎么找到正确的 mac 地址

但是，互联网上的IP报文并不携带MAC地址啊？它是投递到小区了，怎么找到正确的网卡呢？

这时就需要ARP协议来帮忙了。

ARP协议在你家/你公司的出口==路由器里面维护一张ARP表==，记录了本地局域网里面每一块网卡的MAC地址和IP地址的对应关系；互联网过来个报文，一看IP地址是202.11.123.13，ARP表一查，MAC地址FE.AC.12.34.56.78，于是在外面包装一层，打包成以太网数据，局域网一丢，完事。

注意，这里是在IP报文外面附加个以太网报头，并不影响IP报文本身。

换句话说，IP并不在乎自己的承载协议是不是以太网协议、也不在乎物理地址是不是MAC地址——所以才说IP地址和MAC地址毫无关系——你完全可以用另外一套地址协议取代以太网/MAC地址。只要实现个自己特有的ARP体系即可。

举例来说，你自己玩无线电，自己定了个地址协议，用甲、乙、丙、丁标记不同的接收机（或者用载波频率90MHZ、94MHZ、96MHZ、104MHZ区分也没问题）；那么只要你做一个甲、乙、丙、丁和IP的对应表、正确实现了相关地址的翻译工作，这些接收机就可以通过互联网访问，对IP报文没有丝毫影响。

## NAT

我们用的PC、手机往往有一个局域网ip地址，一般是192.168.0.*；这个地址并不能用于互联网访问。==它和真实的互联网地址之间可以通过NAT协议相互转换。==

比如，路由器的互联网地址是202.10.11.123，你的局域网ip地址是192.168.1.16；当你访问互联网时，路由器会把你的IP地址替换成202.10.11.123然后才发送到互联网；互联网服务器回应你时，也会使用202.10.11.123这个地址（也就是你的路由器的互联网地址）。

然后，你的路由器会维护一个对外通信端口和内部ip的对应表。比如，它把你的报文通过端口14566和互联网服务器通讯；那么当端口14566端口收到报文时，它就会把ip地址202.10.11.123替换成你的局域网ip 192.168.1.16，然后再查ARP表、打包成以太网报文并最终完成通信。

这个过程，就是所谓的NAT（网络地址转换）。

如果你所在的==公司很大==的话，路由器可能仅仅完成局域网IP的翻译工作，报文仍然需要借助路由协议投递到你所在部门的子网，然后再打包成以太网报文，这才能投递给你。

注意，在公司很大这个场景下，不同部门的子网可能仍然是通过以太网协议接入的；因此，“报文投递到正确子网”这一步也要打包成以太网报文、投递给子网网关（此时用的MAC地址是子网网关的MAC）；然后子网网关从中解出IP报文、把以太网包头丢弃，之后再次用你的MAC打包成以太网包，这才能投递给你。

其中，公司主网关使用部门子网网关MAC打包、投递这一步，对你来说是不可见的——甚至于，这一步可能在互联网上就要执行十多次（没错，你用trace router追踪时，看到的每一跳可能都对应着一个重新打包-解包过程）。



由此也可见，IP地址和MAC地址其实是毫无瓜葛的。两者仅仅是在传输过程中偶遇、旋即分开而已——那仅仅是报文投递过程中的一个实现细节罢了。

## 交换机

**传统交换机只处理以太网报文，完全不看IP层的内容**。每次主机发送以太网帧，源地址填写自己的MAC地址，目的地址填写对端的MAC地址或者广播地址。交换机每次收到以太网帧，就在**MAC地址表**中记录这个帧的源MAC地址和收到这个帧的端口，这叫做**MAC地址学习**，然后再看这个帧的目的MAC地址，如果在MAC地址表中找到，就发给对应的端口，否则广播。

路由器则不同，它通过收到包的**IP地址**，查找**路由表**来决定转发到哪个端口。

## 总结

* 一台电脑访问互联网，会使用路由器的网络地址作为公网的 ip 地址，路由器会为该请求开放一个端口，在拿到响应的时候，会先查询对应的内网 IP（NAT转换），查询 ARP 表找到对应的 mac 地址，包装以太网进行传输。



# DNS

## 缓存

### 1. 浏览器 DNS缓存

浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关。

浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。==每种浏览器都有一个固定的DNS缓存时间==，其中==Chrome的过期时间是1分钟==，在这个期限内不会重新请求DNS。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入

```
chrome://net-internals/#dns
```

* Chrome 缓存 1 分钟

### 操作系统缓存

OS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。



# tcp 相关

## **开启Keep-Alive的优缺点：**
优点：Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。
缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。

## **当保持长连接时，如何判断一次请求已经完成**

1. **Tcp的Keepalive** （检测在线策略）

   连接建立之后，如果客户端一直不发送数据，或者隔很长时间才发送一次数据，当连接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，连接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。
   TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个==数据为空的报文（侦测包）==给对方，如果对方回应了这个报文，说明对方还在线，连接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持连接。



## 为什么三次握手

对比 SSL 更强调安全性

1. 可靠性
2. 服务端作为数据给出方，如果不确认是否建立连接，一直等待浪费资源。

## 三次握手

客户端首先发送SYN数据包，然后服务器发送SYN+ACK数据包，最后客户端发送ACK数据包，接下来就可以发送内容了。这三个数据包的发送过程，叫做TCP握手。

==其中ACK报文是用来应答的，SYN报文是用来同步的==



## 四次挥手

* 因为TCP是全双工通信的，相当于两个 socket 必须要全部断开。

  因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。

* https://zhuanlan.zhihu.com/p/374998210?utm_source=wechat_session&utm_medium=social&utm_oi=713439222677118976&utm_campaign=shareopn

  
  
  
  
  fin -> 
  
  <- ack
  
  
  
  



# http 相关

## 1. SSL延迟

https://www.ruanyifeng.com/blog/2014/09/ssl-latency.html

* https 要比 http 慢2~100倍。

## **Keep-Alive timeout**——http 链接的保持时长

* Tcp 通道的占用时长



