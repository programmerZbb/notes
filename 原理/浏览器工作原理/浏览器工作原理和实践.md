# 参考

* 极客时间浏览器工作原理和实践

# why

## 1. 具备评估项目可行性的能力——技术选型



## 2. 从更高的维度审视页面——web页面性能的提升

* 当用户请求一个网站时，如果在 1 秒内看不到关键内容，用户会产生任务被中断的感觉。——首屏渲染
* 当用户点击某些按钮时，如果 100ms 内无法响应，用户会感受到延迟。——action 响应，包括异步请求
* 如果 Web 中的动画没有达到 60fps，用户会感受到动画的卡顿。——动画



# 进程线程

https://juejin.cn/post/6991849728493256741#heading-1

## 进程

当我们启动某个程序时，操作系统会给该程序创建一块内存(当程序关闭时，该内存空间就会被回收)，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境就叫`进程`

* **计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位，是操作系统结构的基础**

  系统进行资源分配的基本单位。（主要描述资源分配）

* 存放代码、运行中的数据、一个执行任务的主线程。

## 线程

线程（英语：thread）是**操作系统能够进行运算调度的最小单位**。

* cpu 运算调度的最小单位（主要描述运算调度）

## 进程和线程关系

进程和线程的关系特点是这样的：

- 进程与进程之间完全隔离，互不干扰，一个进程崩溃不会影响其他进程，避免一个进程出错影响整个程序
- 进程与进程之间需要传递某些数据的话，就需要通过`进程通信管道IPC`来传递
- 一个进程中可以并发多个线程，每个线程并行执行不同的任务
- 一个进程中的任意一个线程执行出错，会导致这个进程崩溃
- 同一进程下的线程之间可以直接通信和共享数据
- 当一个进程关闭之后，操作系统会回收该进程的内存空间



作者：沐华
链接：https://juejin.cn/post/6991849728493256741
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# Chrome 架构

## 1. 打开一个页面为什么有4个进程

* 一切都源于 Chrome 推出的 多进程 架构

  ![chrome-process.png](./imgs/chrome-process.png)

### 进程和线程补充

* 多线程可以并行处理任务，但是==**线程是不能单独存在的，它是由进程来启动和管理的**==。那什么又是进程呢？——进程启动和管理线程

  进程启动和管理线程

> **一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。
>
> 线程就是进程运行中的函数，方法

一个程序运行实例，（相当于一个 new 创建一块内存），能够存放运行的代码、运行中的数据和执行任务的主线程，这个运行的环境统称进程。

* 如图一个进程下的线程

![process-thread](./imgs/process-thread.png)

* 线程是依附于进程的，进程中使用多线程并行处理能提升运算效率

  node 为啥是多进程的，因为每个进程内只能有一个线程，所以为了利用多核能力，采用多进程编程

总结：

1. 进程中任意一线程执行出错，都会导致整个进程的崩溃

2. ==线程之间共享进程中的数据==

   ![threads-share-data](./imgs/threads-share-data.png)

​	从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 	继续从 A、B、C 中读取数据，用来显示执行结果。

3. 当一个进程关闭之后，操作系统就会回收进程所占用的内存

   当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

4. **进程之间的内容相互隔离。**

   进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。

### 进程间通信（IPC）

* 进程间通信一般有如下方法

  (1) 半双工Unix管道

  (2) FIFOs(命名管道)

  (3) ==消息队列==

  (4) 信号量

  (5) ==共享内存==

  (6) ==网络Socket==：例如 RPC 的方式

详细参考：https://www.jianshu.com/p/c1015f5ffa74

#### 通信

`管道通信`：就是操作系统在内核中开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这个缓冲区里，进程2就可以读取了

`消息队列通信`：消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制

`共享内存通信`：就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是`IPC`方式

`信号量通信`：比如信号量初始值是1，进程1来访问一块内存的时候，就把信号量设为0，然后进程2也来访问的时候看到信号量为0，就知道有其他进程在访问了，就不访问了

`socket`：其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到socket的通信方式了，比如发起http请求，服务器返回数据

* 参考：https://juejin.cn/post/6991849728493256741



## Chrome 多进程架构

目的：稳定性、流畅性和安全性

![chrome-process-framework](./imgs/chrome-process-framework.png)

从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程(一个tab有一个渲染进程，包含关键渲染步骤的管理)和多个插件进程。

* 个人理解：就像时间循环一样，进程和线程都需要启动和管理，只是宿主不一样。

  进程：实例；线程：方法

### 进程详解

* ==浏览器进程==：主要负责解码显示、用户交互、子进程管理，同时提供存储等功能。
* 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，==排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中==，默认情况下，==Chrome 会为每个 Tab 标签创建一个渲染进程==。出于安全考虑，渲染进程都是运行在沙箱模式下。
  * 排版引擎 blink
  * Javascript 引擎 V8
* GPU  进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
* 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
* 插件进程：主要是负责插件的运行，因==插件易崩溃，所以需要通过插件进程来隔离==，以保证插件进程崩溃不会对浏览器和页面造成影响。

### 小 tips

* 同一站点共享同一个渲染线程

  这也是在公司使用 一个项目打了断点，gitlab打不开的原因

> 是这样的，通常情况下是一个页面使用一个进程，但是，有一种情况，叫"同一站点(same-site)"，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：
>
> https://time.geekbang.org
> https://www.geekbang.org
> https://www.geekbang.org:8080
> 都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事就行了。
>
> Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。
>
> 直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。
>
> 所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。
>
> 为什么要让他们跑在一个进程里面呢？
>
> 因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。

* ==同一站点和同源策略的区别！！！==

### 目前的问题

不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

- **更高的资源占用**。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- **更复杂的体系架构**。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

### QA

* 打开浏览器两个tab有几个进程

  > 1:==如果页面里有iframe的话，iframe也会运行在单独的进程中！(单独新开一个进程，可以用做页面优化)==
  >
  > * 关于iframe是否多开一个进程可以参考该答案：https://stackoverflow.com/questions/11510483/will-a-browser-give-an-iframe-a-separate-thread-for-javascript，看起来Chrome默认采用相同的进程，但是线程不是同一个。参考：chrome://flags/#enable-isolated-sandboxed-iframes
  >
  > 2:如果页面里有插件，同样插件也需要开启一个单独的进程！
  > 3:如果你装了扩展的话，扩展也会占用进程
  > 4:如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们会公用一个渲染进程
  >
  > 这些进程都可以通过chrome的任务管理器来查看。
  
  * iframe 也会新开一个线程，能作为一个优化的手段

## 浏览器中的进程和线程

阅读：https://zhuanlan.zhihu.com/p/416161636

### 渲染进程中的线程（强调渲染线程）

`GUI渲染线程`：负责渲染页面，解析html和CSS、构建DOM树、CSSOM树、渲染树、和绘制页面，重绘重排也是在该线程执行

`JS引擎线程`：一个tab页中只有一个JS引擎线程(单线程)，负责解析和执行JS。**它GUI渲染进程不能同时执行，只能一个一个来，如果JS执行过长就会导致阻塞掉帧**

`计时器线程`：指setInterval和setTimeout，因为JS引擎是单线程的，所以如果处于阻塞状态，那么计时器就会不准了，所以需要单独的线程来负责计时器工作

`异步http请求线程`： XMLHttpRequest连接后浏览器开的一个线程，比如请求有回调函数，异步线程就会将回调函数加入事件队列，等待JS引擎空闲执行

`事件触发线程`：主要用来控制事件循环，比如JS执行遇到计时器，AJAX异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件触发时，就把事件添加到待处理队列的队尾，等JS引擎处理

>
>
>在浏览器中，通常会有以下几种线程：
>
>
>
>\1. 主线程（Main Thread）：主要负责处理用户交互、解析和执行JavaScript代码、页面渲染、布局计算等任务。
>
>
>
>\2. 渲染线程（Rendering Thread）：负责将网页内容转换为屏幕上的像素并进行绘制，执行CSS动画、绘制页面元素等。
>
>
>
>\3. JavaScript引擎线程：负责执行JavaScript代码，例如V8引擎线程。
>
>
>
>\4. 定时器触发线程（Timer Thread）：负责处理定时器任务，管理setTimeout和setInterval等定时器的执行。
>
>
>
>\5. 事件触发线程（Event Thread）：负责处理DOM事件、鼠标点击、键盘输入等用户操作产生的事件。
>
>
>
>\6. HTTP请求线程（HTTP Request Thread）：负责处理HTTP请求和响应，从服务器获取网页资源。
>
>
>
>\7. GPU线程（GPU Thread）：负责处理使用硬件加速的动画和渲染任务，例如执行CSS动画、绘制页面元素等。
>
>​	* 这也是为什么 js 的执行阻塞不了 css 动画，这也是优化手段之一。
>
>
>
>这些线程之间可以并行执行，相互协作，以提供流畅的用户体验和高性能的网页渲染。

* 如上是 chatgpt 的回答，更合理一些。可以把上面的一个个线程当成有固定能力的函数。
* 也可以使用 performance 工具录制完查看各个线程使用情况。

### 主线程

**主线程**用于浏览器处理用户事件和页面绘制等。默认情况下，浏览器在一个线程中运行一个页面中的所有 JavaScript 脚本，以及呈现布局，回流，和垃圾回收。这意味着一个长时间运行的 JavaScript 会阻塞线程，导致页面无法响应，造成不佳的用户体验。

* 渲染线程就是主线程！

  不对吧，主线程更像是渲染线程和js引擎线程的调度中心。确实这样，这也是为什么 js 引擎线程和渲染线程会冲突的原因。

> 由于主线程负责执行多种任务，因此在处理复杂页面和大量JavaScript代码时，主线程可能会面临性能瓶颈。为了避免页面的卡顿和响应延迟，开发人员通常会采用异步编程、Web Workers、使用CSS动画等技术来优化网页性能。

#### 在 performance 中的提现

* 录制完 performance 后，就能看到 main 现成，main 现成就是对事件循环的调度。

### 线程通信

* 进程内的线程是可以直接通信和共享数据的。那么计时器线程、异步http请求线程、事件监听线程是怎么把回调函数加入到异步队列中的（主要描述通信问题）

### GPU 加速动画

* ==渲染层提升==

> 在CSS动画中，渲染层提升是一种优化技术，可以通过将动画元素移动到单独的图层上，以利用硬件加速来提高动画的性能和流畅度。
>
> 
>
> 当一个元素发生动画时，==浏览器通常会将该元素所在的图层标记为需要重新绘制==，然后将其重新绘制在屏幕上。对于复杂的动画效果或大量的元素，这可能会导致性能下降和动画卡顿。
>
> 
>
> ==通过将动画元素移动到单独的图层上，浏览器可以利用硬件加速来处理动画，从而提高性能==。这样做的好处包括：
>
> 
>
> \1. 减少页面的重绘和重排次数，提高动画的流畅度。
>
> \2. 可以利用GPU来加速动画的渲染，提高性能。
>
> \3. 允许动画元素在自己的图层上独立绘制，避免影响其他元素的渲染。
>
> 
>
> 您可以通过以下几种方式来实现CSS动画的渲染层提升：
>
> 
>
> \1. 使用 `transform` 和 `opacity` 属性：这两个属性通常会触发GPU硬件加速，可以将动画元素移动到单独的图层上。
>
> 
>
> \2. 使用 `will-change` 属性：通过在CSS中使用 `will-change` 属性，可以告知浏览器哪些属性将会被动画使用，帮助浏览器优化渲染。
>
> 
>
> \3. 使用 `translate3d` 或 `translateZ`：在动画元素上应用3D转换（`translate3d`）或Z轴转换（`translateZ`）可以触发GPU加速，促进渲染层提升。
>
> 
>
> 请注意，虽然渲染层提升可以提高性能，但过度使用也可能会导致资源占用过多，因此应该根据具体情况进行优化。

* 重排本质还在渲染线程内，收到主线程控制

可以参考例子：https://www.phpied.com/css-animations-off-the-ui-thread/

## 未来面向服务的架构

为了解决这些问题，在 2016 年，Chrome 官方团队使用“**面向服务的架构**”（Services Oriented Architecture，简称**SOA**）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而**构建一个更内聚、松耦合、易于维护和扩展的系统**，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。





# TCP 协议再谈

> 在衡量 Web 页面性能的时候有一个重要的指标叫“**FP（First Paint）**”，是**指从页面加载到首次开始绘制的时长**。这个指标直接影响了用户的跳出率，更快的页面响应意味着更多的 PV、更高的参与度，以及更高的转化率。那什么影响 FP 指标呢？其中一个重要的因素是**网络加载速度**。

* 从首屏加载时长引出网络加载速度

注意：

* 是一个数据流协议

  > 但TCP本来就是基于字节流而不是消息包的协议，它自己说的清清楚楚：我会把你的数据变成字节流发到对面去，而且保证顺序不会乱，但是你要自己搞定字节流解析。

## 数据包的完整旅程

> **互联网，实际上是一套理念和协议组成的体系架构**。

### 1. IP:  把数据包送达目的主机——贴上地址条

> ==数据包要在互联网上进行传输，就要符合**网际协议**（Internet Protocol，简称**IP**）标准==。互联网上不同的在线设备都有唯一的地址，地址只是一个数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地。

**计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。**

#### ip 头

> 如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

* 主要就是数据包加了ip头

### 2.  UDP: 把数据包送达应用程序

* 肯定要加端口信息

  > 因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“**用户数据包协议**（User Datagram(数据报) Protocol）”，简称**UDP**。

  > **IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序**。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

![udp-process](./imgs/udp-process.png)

Udp 的问题：

* 在使用 UDP 发送数据时，各种因素可能导致数据包出错，虽然 UDP 能够验证数据是否正确，但是对于错误的数据包，不提供重发机制，只会丢弃当前的包。没有重发机制。

* 发送之后无法得知是否到达目的地

* 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

  无法支持大文件发送

虽说**UDP 不能保证数据可靠性，但是传输速度却非常快**，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

### 3. TCP：把数据完整的送达应用程序

**TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、==基于字节流的(不是数据包协议，和UDP区别。准确的说 TCP不存在粘包问题，只是认为的给数据流分了包)==传输层通信协议**。

- 对于数据包丢失的情况，TCP 提供重传机制；
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

#### + 提供用于排序的序列表

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

![tcp-process](./imgs/tcp-process.png)

#### 生命周期

一个完整的 TCP 连接的生命周期包括了“**建立连接**”“**传输数据**”和“**断开连接**”三个阶段。

![tcp-whole-process](./imgs/tcp-whole-process.png)

- **首先，建立连接阶段**。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。==**面向连接**是指在数据通信开始之前先做好两端之间的准备工作。==所谓**三次握手**，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。

  面向连接，基于数据流

- **其次，传输数据阶段**。在该阶段，**接收端需要对每个数据包进行确认操作**，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

  * 需要接收端进行数据接收确认，在规定时间内没有收到接收端的反馈，则判断为数据包丢失，并触发重发机制

- **最后，断开连接阶段**。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

到这里你应该就明白了，TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

# 再谈 http

> 而 HTTP 协议，正是建立在 TCP 连接基础之上的。**HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础**，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，**HTTP 也是浏览器使用最广的协议**，所以要想学好浏览器，就要先深入了解 HTTP。

* 是浏览器和服务端的协议，一般由浏览器发起。
* 如果想使用其他的自定义协议，比如说 RPC，那就要直接操作 二进制数据，这就是为啥node要使用 buffer 进行封装。

## 带着问题

- HTTP 网络请求的第一步是做什么呢？结合上图看，是和服务器建立 TCP 连接。
- 那建立连接的信息都有了吗？[上一篇文章](https://time.geekbang.org/column/article/113550)中，我们讲到建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。
- 那怎么获取 IP 地址和端口号呢？这得看看我们现在有什么，我们有一个 URL 地址，那么是否可以利用 URL 地址来获取 IP 和端口信息呢？

## dns

负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“**域名系统**”，简称**DNS**（Domain Name System）。

## 浏览器端发起 http 请求流程

### 1. 构建请求

### 2. 查找缓存

### 3. 准备 IP 地址和端口

### 4. 等待 TCP 队列

现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？

答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。

当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。

* 在 waterfall 中能看到
* chrome 同一个域名最多只能建立6个 tcp 连接

### 5. 建立 TCP 连接



### 6. 发送http请求

* 浏览器http请求

  ![http](https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png)

	* 请求行：请求方法、请求URI、http版本



### 服务端返回http响应

#### 返回请求

> 随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送**响应头**。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。

* 主要是指 content-type 吧？

  Content-type 参考：https://www.iana.org/assignments/media-types/media-types.xhtml

#### 断开连接

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。

不过如果浏览器或者服务器在其头信息中加入了：

```
Connection:Keep-Alive 
```

> 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。**保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度**。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

* Todo tcp 断开连接

#### 重定向

### 问题

1. ### 为什么很多站点第二次打开速度会很快？

   * 从==核心请求路径出发==，（这也是后期进行web优化的侧重点，和关键渲染路径一样的地位）。

     **DNS 缓存**和**页面资源缓存**这两块数据是会被浏览器缓存的

     > 其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来，这里就不做过多分析了。

   * 浏览器缓存


简单来说就是缓存了DNS、缓存了静态文件资源

> 简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。

### 浏览器缓存

1. 服务器返回**HTTP 响应头**给浏览器时，浏览器是**通过响应头中的 Cache-Control 字段来设置是否缓存该资源**。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。

   ```
   Cache-Control:Max-age=2000
   ```

2. 这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。

3. 如果缓存过期了（到达了设置的时长），浏览器则会继续发起网络请求，并且在**HTTP 请求头**中带上：

   ```typescript
   If-None-Match:"4f80f-13c-3a1xb12a"
   ```

更多参考：

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching
