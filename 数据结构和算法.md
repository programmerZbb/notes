# 复杂度

* o 是量级

  空间复杂度，时间复杂度

* o(n)、o(n^2)

  o(n) 线性增长，可以接受。o(n^2) 复杂度较高，不能接受



# 数据结构

* 都是为了解决实际的问题。

## 1. 数组

* 普通语言的数组不能存放不同的数据类型，因此所有在封装通常存放在数据的是Object 类型，方便扩展

* 常见语言数组容量不会自动改变（需要申请一个更大容量的数组来扩容）

* 常见语言的数组进行中间插入和删除操作性能比较低

  因为数组结构是线性的，存储空间是连续的，操作一个需要移动剩余元素的位置，性能较低。

数组的优势：

* index 数组的索引，查找的性能很高

## 2. 栈（stack）

* 数组能够在任意位置插入和删除数据，有些时候我们为了实现某些功能必须对这种任意性加以限制

* 栈和队列就是常见的受限的线性结构

### 2.1 特点

* ==后进先出（LIFO）==
  其限制的是只能在表的一端进行插入和删除运算，这一端被称为栈顶，相对的，另一端被称作栈底。
* 受限的数据结构，只能在栈顶操作数据

### 2.2 应用场景

* 十进制转二进制，判断字符串的括号是否有效，函数调用堆栈

## 3. 队列（queue）

* 受限的数据结构，先进先出，表的前端进行删除，表的后端进行插入
* 先进先出

### 3.2 应用场景

* 所有需要先进先出的场景
* 例子：食堂排队打饭，js 异步中的任务队列，计算最近请求次数。（面对那些无法同时处理的场景，采用队列这种数据结构。）

## 4. 链表

* 多个元素组成

### 前端和链表

* 原型链

## 5. 集合

* 集合是一组==无序且唯一==的数据结构
* Es6 中 Set

### 应用场景

* 数组去重、判断某元素是否在集合中、就集合交集

## 6. 字典

* 与集合类似，字典也是一种存储唯一值的数据结构，但他是以键值对的形式来存储。
* se6 中添加了字典，Map

## 7. 树

* 一种分层数据的抽象模型。

* 前端工作中常见的树：DOM 树，级联选择，树形控件...

* js 中没有树，可以使用 Object 和Array 构建树

  用 Object 创建的链式对象不算数，因为是一个节点，算链表
  
* ==自我总结==：树的算法都是先产生算法，然后才会产生遍历顺序。而且算法都是递归，因此只要记住递归即可实现树的算法。

### 什么是深度/广度优先遍历（递归&队列）

* 深度优先遍历：尽可能深的搜索树的分支
* 广度优先遍历：先访问离根节点最近的节点。

如图：

![WechatIMG73](./数据结构和算法/imgs/WechatIMG73.png)

### 深度优先遍历算法口诀（dfs）

* 访问根节点
* 对根节点的 children 挨个进行深度优先遍历

### 广度优先遍历算法口诀(bfs)

* 新建一个队列，把根节点入队
* 把队头出队并访问
* 把队头的 children 挨个入队
* 重复 二三步骤，直到队列为空 

### 二叉树

* 树中每个节点最多只能有两个子节点
* js 中通常使用 Object 来模拟二叉树

#### 先序遍历

* 算法口诀
  * 访问根节点
  * 对根节点的左子树进行先序遍历
  * 对根节点的右子树进行先序遍历

#### 中序遍历

* 对根节点的左子树进行中序遍历
* 访问根节点
* 对根节点的右子树进行中序遍历

#### 后序遍历算法口诀

* 对根节点的左子树进行后序遍历
* 对根节点的右子树进行后序遍历
* 访问根节点

#### 三种遍历非递归版

### 前端与树：遍历 JSON 的所有节点值

* 深度优先遍历

## 8. 图

* 图是网络结构的抽象模型，是一组由边连接的节点

* js 中没有图，但是可以用 Object 和 Array 构建图
* 图的表示法：邻接矩阵、邻接表、关联矩阵......

### 图的表示法：邻接矩阵

![邻接矩阵](./数据结构和算法/imgs/邻接矩阵.png)

### 图的表示法：邻接表

![邻接表](./数据结构和算法/imgs/邻接表.png)

* 不一定要是数组，链表也行。只要能描述清楚指向关系极客。

### 常用操作

* 深度优先遍历
  * 访问根节点
  * 对根节点的==没有访问过的相邻节点==挨个进行深度优先遍历
* 广度优先遍历
  * 新建一个队列，把根节点入队
  * 把队头出队并访问
  * 把对队头的没访问过的相邻节点入队

## 9. 堆

* 堆是一种特殊的完全二叉树

* 所有的节点都大于等于（最大堆）或小于等于（最小堆）它的子节点。`6>5>4>2`

  如图完全二叉树，子节点填满

  ![完全二叉树](./数据结构和算法/imgs/完全二叉树.png)

* JS 中通常用数组表示堆
* 左侧子节点的位置是 `2*index+1`
* 右侧子节点的位置是 `2*index+2`
* 父节点位置`(index - 1) / 2`

![数组表示堆](./数据结构和算法/imgs/数组表示堆.png)

### 应用

* 堆能高效、快速的找出最大值和最小值，时间复杂度：O(1)

# 算法

## 1. 大O 表示法

* 公司分为小中大公司规模，大概描述
* 在算法中可以用类似的快捷方式来描述计算机算法的效率
* 在计算机中这种粗略的度量被称为“大O”表示法
* 在算法比较过程中，我们可能会说A的算法比B快两倍，但是这样的比较有时候没有意义
* 在数据项个数发生变化时，算法效率会跟着发生变化
* 所以我们通常使用一种算法的速度会如何跟随着数据量的变化的（跟随数据量变化）

## 2. 常见的大O表示形式

| 符号 | 名称   |描述|
| ---- | ------ |----|
| O(1) | 常数的 |算法不会随着数据项的变化而变化|
| O(log(n)) |对数的|二分法效率较高（100万查找，大约20次）|
|O(n)|线性的||
|O(nlog(n))|线性和对数乘积|快速排序|
|O(n2)|平方|冒泡、插入|
|O(2n)|指数的||

* 描述的随着数据量的变化的变化曲线，O(log(n))几乎重叠，并不是完全准确，需要变化的来获取复杂度

![企业微信截图_158356132222](.\picture\react 16\企业微信截图_158356132222.png)

* 大O表示法的推导公式，比如2N2+3n+1
  1. 用常量1取代运行时间中所有的加法常量；比如 + 76 用 O(1)取代
  2. 在修改后的运算函数中，只保留最高阶项；`2n2+3n+1`只保留 O(2n2)
  3. 如果最高存在且不为1，则去除这个项相乘的常数; `2n2` 2不为1，可以去除

## 3.排序算法

* 排序算法有很多：冒泡、选择、插入排序、归并排序、计数排序（counting sort）、基数排序(radix sort)、希尔排序、堆排序、桶排序、快速排序
* 简单排序：冒泡、选择排序、插入排序
* 高级排序：希尔排序、快速排序（笔试题推荐、最快）

### 3.1 冒泡（比较+交换）

* 冒泡排序 比较次数 (N-1)+(N-2)+...+1 = N*(N-1)/2  O(n2)

* 交换次数：N*(N-1)/4  O(n2)，估算每两次需要比较一次

  前一个后一个对别交换（这是核心！！！！）

## 3.2 选择排序

* 选择最小的放到前边
* 比较次数 O(n2)
* 交换次数 O(n)

## 3.3 插入排序

* 简单排序中效率最高的，
* 局部有序
* 最坏复杂度比较次数： n*(n-1)/2  平均除2  n*(n-1)/4  O(n2)
* 交换次数： 最差 n(n-1)/2，平均 n(n-1)/4


![企业微信截图_15835863469715](.\picture\react 16\企业微信截图_15835863469715.png)// 插入排序，默认前边的有顺序

```js
function sort (arr) {
    for(var i=0;i<arr.length;++i) {
        let j = i
        let temp 
        // 默认前边的有顺序，直接拿新进来的去插入
        while (j>=0 && arr[j-1] >arr[j]) {
            temp = arr[j]
            arr[j] = arr[j-1]
            arr[j-1] = temp
            j--
        }
    }
    return arr
}

console.log(sort([2,1,7,2,4,6,3,1]))
```



## 3.4 希尔排序

* 以前认为排序无法超越 O(n2),知道希尔排序出现。
* 

![企业微信截图_15835863469715](.\picture\react 16\企业微信截图_15835863469715.png)

## 快速排序

* 选一个数字左右划分，分而治之，递归实现

1. 枢纽的选择，第一个中间数，一旦选定，位置不变

```jsx
let arr = []

function quickSort () {
    quick(0, arr.length-1)
}

function quick (left, right) { 
    if (left >= right-1) {
        return
    }
    let pivot = findPivot(left, right)
    let i = left
    let j = right - 1
    while(true) {
        while(arr[++i] < pivot) {}
        while(arr[--j] > pivot) {}
        if (i < j) {
            swap(i, j)
        } else {
            break
        }
    }
    swap(i, right - 1)
    quick(left, i-1)
    quick(i+1, right)
}

function swap (i, j) {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function findPivot (i, j) {
    let x = Math.floor((i + j)/2)
    if (arr[i] > arr[x]) {
        swap(i, x)
    }
    if (arr[x] > arr[j]) {
        swap(x, j)
    }
    if (arr[i] > arr[x]) {
        swap(i, x)
    }
    swap(x, j-1)
    return arr[j-1]
}
arr = [6,3,2,9,1,50,0,119,20,118]
quickSort()
console.log(arr)

```

`log2(N)` 是二分法的复杂度，`n(1/2k)=1` ,k = log2(n)



# leetcode 刷题

* 查看参数和return 注释怎么写
* js 中构造函数怎么写
* 链表输入都是 `[1, 2]`数组输入的形式

## 20. 有效的括号

* 一前一后，查找，就是栈的结构。后入先出。

## 933 最近的请求次数

* js 中类的基础数据绑定在 function 内的 this 上，能够确保实例出来的对象都是使用同一个数据
* js 中的方法一般都绑定在 prototype 上
* 先入先出的概念，使用队列这种数据结构去描述

## 237. [删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

## 206. 反转链表

* 快慢指针法，每次都走一格，交换

## 2. 两数相加

## 根据路径（数组）遍历 json

## 349 两个数组交集

* 用集合和字典分别做

## 1. 两数之和

* 关键词唯一性
* 没有找到就先登记，然后查找

## 3. 无重复字符的最长子串

* 双指针滑动窗口

## 76. 最小覆盖子串

## 65. 有效数字







# 总结方法

## 1. 队列的使用

* 所有的先入先出，有序的，控制出队条件的，就应该使用队列这种数据结构。

## 2. 递归和while 的使用

* 如果出现自己想调用自己的情况，可以使用递归；如果出现递归的方法中要使用一个共同的变量（所有递归函数都要使用），可以考虑使用 while 循环，创造一个自己调用自己的封闭区域。

