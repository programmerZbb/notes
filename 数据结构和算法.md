# 复杂度

* o 是量级

  空间复杂度，时间复杂度

* o(n)、o(n^2)

  o(n) 线性增长，可以接受。o(n^2) 复杂度较高，不能接受



# 数据结构

## 1. 数组

* 普通语言的数组不能存放不同的数据类型，因此所有在封装通常存放在数据的是Object 类型，方便扩展

* 常见语言数组容量不会自动改变（需要申请一个更大容量的数组来扩容）

* 常见语言的数组进行中间插入和删除操作性能比较低

  因为数组结构是线性的，存储空间是连续的，操作一个需要移动剩余元素的位置，性能较低。

数组的优势：

* index 数组的索引，查找的性能很高

## 2. 栈（stack）

* 数组能够在任意位置插入和删除数据，有些时候我们为了实现某些功能必须对这种任意性加以限制

* 栈和队列就是常见的受限的线性结构

### 2.1 特点

* 后进先出（LIFO）
  其限制的是只能在表的一端进行插入和删除运算，这一端被称为栈顶，相对的，另一端被称作栈底。
* 受限的数据结构，只能在栈顶操作数据

## 3. 队列（queue）

* 受限的数据结构，先进先出，表的前端进行删除，表的后端进行插入

# 算法

## 1. 大O 表示法

* 公司分为小中大公司规模，大概描述
* 在算法中可以用类似的快捷方式来描述计算机算法的效率
* 在计算机中这种粗略的度量被称为“大O”表示法
* 在算法比较过程中，我们可能会说A的算法比B快两倍，但是这样的比较有时候没有意义
* 在数据项个数发生变化时，算法效率会跟着发生变化
* 所以我们通常使用一种算法的速度会如何跟随着数据量的变化的（跟随数据量变化）

## 2. 常见的大O表示形式

| 符号 | 名称   |描述|
| ---- | ------ |----|
| O(1) | 常数的 |算法不会随着数据项的变化而变化|
| O(log(n)) |对数的|二分法效率较高（100万查找，大约20次）|
|O(n)|线性的||
|O(nlog(n))|线性和对数乘积|快速排序|
|O(n2)|平方|冒泡、插入|
|O(2n)|指数的||

* 描述的随着数据量的变化的变化曲线，O(log(n))几乎重叠，并不是完全准确，需要变化的来获取复杂度

![企业微信截图_158356132222](.\picture\react 16\企业微信截图_158356132222.png)

* 大O表示法的推导公式，比如2N2+3n+1
  1. 用常量1取代运行时间中所有的加法常量；比如 + 76 用 O(1)取代
  2. 在修改后的运算函数中，只保留最高阶项；`2n2+3n+1`只保留 O(2n2)
  3. 如果最高存在且不为1，则去除这个项相乘的常数; `2n2` 2不为1，可以去除

## 3.排序算法

* 排序算法有很多：冒泡、选择、插入排序、归并排序、计数排序（counting sort）、基数排序(radix sort)、希尔排序、堆排序、桶排序、快速排序
* 简单排序：冒泡、选择排序、插入排序
* 高级排序：希尔排序、快速排序（笔试题推荐、最快）

### 3.1 冒泡（比较+交换）

* 冒泡排序 比较次数 (N-1)+(N-2)+...+1 = N*(N-1)/2  O(n2)
* 交换次数：N*(N-1)/4  O(n2)，估算每两次需要比较一次

## 3.2 选择排序

* 选择最小的放到前边
* 比较次数 O(n2)
* 交换次数 O(n)

## 3.3 插入排序

* 简单排序中效率最高的，
* 局部有序
* 最坏复杂度比较次数： n*(n-1)/2  平均除2  n*(n-1)/4  O(n2)
* 交换次数： 最差 n(n-1)/2，平均 n(n-1)/4

```js
![企业微信截图_15835863469715](D:\workspace\notes\notes\picture\react 16\企业微信截图_15835863469715.png)// 插入排序，默认前边的有顺序
function insertSort (arr) {
    for(let i = 1;i < arr.length; ++i) {
        let temp
        let j  
        j = i
        temp = arr[j]
        // 这个里面是提升打的值得位置，先把第一个保存，然后后面的换位置
        while(j >= 1 && arr[j] < arr[j-1]) {
            arr[j] = arr[j-1]
            j--
        }
        arr[j] = temp
    }
    return arr
}

console.log(insertSort([1, 4, 3, 2, 98, 11,31, 15, 25, 36]))
```



## 3.4 希尔排序

* 以前认为排序无法超越 O(n2),知道希尔排序出现。
* 

![企业微信截图_15835863469715](.\picture\react 16\企业微信截图_15835863469715.png)

## 快速排序

* 选一个数字左右划分，分而治之，递归实现

1. 枢纽的选择，第一个中间数，一旦选定，位置不变

```jsx
let arr = []

function quickSort () {
    quick(0, arr.length-1)
}

function quick (left, right) { 
    if (left >= right-1) {
        return
    }
    let pivot = findPivot(left, right)
    let i = left
    let j = right - 1
    while(true) {
        while(arr[++i] < pivot) {}
        while(arr[--j] > pivot) {}
        if (i < j) {
            swap(i, j)
        } else {
            break
        }
    }
    swap(i, right - 1)
    quick(left, i-1)
    quick(i+1, right)
}

function swap (i, j) {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

function findPivot (i, j) {
    let x = Math.floor((i + j)/2)
    if (arr[i] > arr[x]) {
        swap(i, x)
    }
    if (arr[x] > arr[j]) {
        swap(x, j)
    }
    if (arr[i] > arr[x]) {
        swap(i, x)
    }
    swap(x, j-1)
    return arr[j-1]
}
arr = [6,3,2,9,1,50,0,119,20,118]
quickSort()
console.log(arr)

```

`log2(N)` 是二分法的复杂度，`n(1/2k)=1` ,k = log2(n)

